


generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum Role {
  ADMIN
  MANAGER
  ACCOUNTANT
}

enum InstallmentStatus {
  PENDING
  PAID
  OVERDUE
}

enum PlanType {
  MONTHLY
  QUARTERLY
  YEARLY
}

enum TxType {
  DEBIT
  CREDIT
}

enum UnitStatus {
  available
  sold
  returned
}

enum InvoiceType {
  customer
  supplier
  contractor
}

enum InvoiceStatus {
  draft
  posted
  paid
  partial
}

enum MaterialMoveType {
  in
  out
  adjust
}

enum BackupLocation {
  onedrive
  gdrive
  local
}

enum BackupStatus {
  ok
  failed
}

enum AccountType {
  asset
  liability
  equity
  revenue
  expense
}

// Auth Models (NextAuth v5 compatible)
model User {
  id           String   @id @default(cuid())
  name         String?
  email        String   @unique
  passwordHash String
  role         Role
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  accounts AuthAccount[]
  sessions Session[]
  AuditLog  AuditLog[] @relation("UserToAuditLog")
}

model AuthAccount {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @map("refresh_token")
  access_token      String? @map("access_token")
  expires_at        Int?    @map("expires_at")
  token_type        String? @map("token_type")
  scope             String?
  id_token          String? @map("id_token")
  session_state     String? @map("session_state")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Parties
model Client {
  id        String   @id @default(cuid())
  name      String
  phone     String?
  email     String?
  address   String?
  note      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  contracts    Contract[]
  invoices     Invoice[]
  journalLines JournalLine[]
  vouchers     Voucher[]
  projects     Project[]
}

model Supplier {
  id     String  @id @default(cuid())
  name   String
  phone  String?
  taxId  String?
  note   String?

  invoices     Invoice[]
  journalLines JournalLine[]
  vouchers     Voucher[]
}

model Contractor {
  id     String  @id @default(cuid())
  name   String
  phone  String?
  taxId  String?
  note   String?

  invoices     Invoice[]
  journalLines JournalLine[]
  vouchers     Voucher[]
}

model Partner {
  id     String  @id @default(cuid())
  name   String
  phone  String?
  note   String?

  projects  ProjectPartner[]
  vouchers  Voucher[]
  journalLines JournalLine[]
  returns   Return[]
}

// Real Estate
model Project {
  id        String   @id @default(cuid())
  code      String   @unique
  name      String
  status    String   // active | paused | closed
  startDate DateTime
  endDate   DateTime?
  budget    Decimal? @db.Decimal(18,2)
  clientId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  client    Client? @relation(fields: [clientId], references: [id])
  units     Unit[]
  journal   JournalEntry[]
  invoices  Invoice[]
  phases    Phase[]
  materials MaterialMove[]
  cashboxes Cashbox[]
  partners  ProjectPartner[]
  vouchers  Voucher[]
}

model Unit {
  id             String     @id @default(cuid())
  code           String     @unique
  projectId      String?
  type           String
  area           Decimal?   @db.Decimal(18,2)
  price          Decimal    @db.Decimal(18,2)
  downPayment    Decimal?   @db.Decimal(18,2)
  reservationFees Decimal?  @db.Decimal(18,2)
  commission     Decimal?   @db.Decimal(18,2)
  maintenance    Decimal?   @db.Decimal(18,2)
  garageShare    Decimal?   @db.Decimal(18,2)
  status         UnitStatus @default(available)
  description    String?
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  project  Project? @relation(fields: [projectId], references: [id])
  contract Contract?
  returns  Return[]
}

model Contract {
  id          String   @id @default(cuid())
  clientId    String
  unitId      String   @unique
  startDate   DateTime
  totalAmount Decimal  @db.Decimal(18,2)
  downPayment Decimal  @db.Decimal(18,2)
  months      Int
  planType    PlanType
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  client      Client   @relation(fields: [clientId], references: [id])
  unit        Unit     @relation(fields: [unitId], references: [id])
  installments Installment[]
}

model Installment {
  id        String   @id @default(cuid())
  contractId String
  amount    Decimal  @db.Decimal(18,2)
  dueDate   DateTime
  status    InstallmentStatus  @default(PENDING)
  paidAt    DateTime?
  matchedBankImportId String? @unique

  contract Contract   @relation(fields: [contractId], references: [id])
  matchedBankImport BankImport? @relation("InstallmentBankImport", fields: [matchedBankImportId], references: [id])
}

model Return {
  id                  String   @id @default(cuid())
  unitId              String
  reason              String?
  complementPartnerId String?
  complementDate      DateTime?
  complementAmount    Decimal? @db.Decimal(18,2)
  resaleStatus        String
  createdAt           DateTime @default(now())

  unit     Unit     @relation(fields: [unitId], references: [id])
  partner  Partner? @relation(fields: [complementPartnerId], references: [id])
}

model ProjectPartner {
  id              String  @id @default(cuid())
  projectId       String
  partnerId       String
  sharePct        Decimal @db.Decimal(5,2)
  walletAccountId String
  previousCarry   Decimal @db.Decimal(18,2) @default(0)

  project Project @relation(fields: [projectId], references: [id])
  partner Partner @relation(fields: [partnerId], references: [id])
  wallet  Account @relation("WalletAccount", fields: [walletAccountId], references: [id])

  @@index([projectId, partnerId])
  @@unique([projectId, partnerId])
  @@map("project_partners")
}

// Accounting
model Account {
  id              String       @id @default(cuid())
  code            String       @unique
  name            String
  type            AccountType
  parentAccountId String?

  parent   Account? @relation("AccountToChildren", fields: [parentAccountId], references: [id])
  children Account[] @relation("AccountToChildren")

  // Back relations (named) from other models
  journalLines JournalLine[] @relation("JournalLineAccount")
  invoiceLines InvoiceLine[] @relation("InvoiceLineAccount")
  cashboxes    Cashbox[]     @relation("CashboxAccount")
  walletOf     ProjectPartner[] @relation("WalletAccount")
}

model Cashbox {
  id        String   @id @default(cuid())
  code      String   @unique
  name      String
  projectId String?
  accountId String
  branch    String?

  project Project? @relation(fields: [projectId], references: [id])
  account Account  @relation("CashboxAccount", fields: [accountId], references: [id])

  vouchers     Voucher[]
  journalLines JournalLine[]
  transfersFrom Transfer[] @relation("FromCashbox")
  transfersTo   Transfer[] @relation("ToCashbox")

  @@index([projectId])
  @@map("cashboxes")
}

model JournalEntry {
  id              String    @id @default(cuid())
  date            DateTime
  ref             String?
  description     String?
  projectId       String?
  posted          Boolean   @default(true)
  reversedEntryId String?
  createdBy       String
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  project  Project? @relation(fields: [projectId], references: [id])
  reversed  JournalEntry? @relation("Reversal", fields: [reversedEntryId], references: [id])
  reversalOf JournalEntry[] @relation("Reversal")
  lines     JournalLine[]

  @@index([date, projectId], map: "journal_entries_idx")
  @@map("journal_entries")
}

model JournalLine {
  id           String   @id @default(cuid())
  entryId      String
  accountId    String
  debit        Decimal  @db.Decimal(18,2) @default(0)
  credit       Decimal  @db.Decimal(18,2) @default(0)
  projectId    String?
  cashboxId    String?
  clientId     String?
  supplierId   String?
  contractorId String?
  partnerId    String?
  invoiceId    String?
  phaseId      String?
  materialId   String?

  entry      JournalEntry @relation(fields: [entryId], references: [id])
  account    Account      @relation("JournalLineAccount", fields: [accountId], references: [id])
  cashbox    Cashbox?     @relation(fields: [cashboxId], references: [id])
  client     Client?      @relation(fields: [clientId], references: [id])
  supplier   Supplier?    @relation(fields: [supplierId], references: [id])
  contractor Contractor?  @relation(fields: [contractorId], references: [id])
  partner    Partner?     @relation(fields: [partnerId], references: [id])
  invoice    Invoice?     @relation(fields: [invoiceId], references: [id])
  phase      Phase?       @relation(fields: [phaseId], references: [id])
  material   Material?    @relation(fields: [materialId], references: [id])

  @@index([entryId, accountId], map: "journal_lines_idx")
  @@map("journal_lines")
}

model Invoice {
  id         String        @id @default(cuid())
  projectId  String?
  type       InvoiceType
  number     String
  date       DateTime
  dueDate    DateTime?
  total      Decimal       @db.Decimal(18,2)
  status     InvoiceStatus
  clientId   String?
  supplierId String?
  contractorId String?
  note       String?

  project    Project?   @relation(fields: [projectId], references: [id])
  client     Client?    @relation(fields: [clientId], references: [id])
  supplier   Supplier?  @relation(fields: [supplierId], references: [id])
  contractor Contractor? @relation(fields: [contractorId], references: [id])
  lines      InvoiceLine[]
  journalLines JournalLine[]

  @@index([projectId, type, date, status], map: "invoices_idx")
  @@map("invoices")
}

model InvoiceLine {
  id          String  @id @default(cuid())
  invoiceId   String
  description String
  materialId  String?
  qty         Decimal @db.Decimal(18,2)
  unitPrice   Decimal @db.Decimal(18,2)
  accountId   String

  invoice  Invoice  @relation(fields: [invoiceId], references: [id])
  material Material? @relation(fields: [materialId], references: [id])
  account  Account  @relation("InvoiceLineAccount", fields: [accountId], references: [id])
}

model Voucher {
  id           String   @id @default(cuid())
  kind         String
  date         DateTime
  cashboxId    String
  projectId    String?
  amount       Decimal  @db.Decimal(18,2)
  clientId     String?
  supplierId   String?
  contractorId String?
  partnerId    String?
  note         String?

  cashbox    Cashbox  @relation(fields: [cashboxId], references: [id])
  project    Project? @relation(fields: [projectId], references: [id])
  client     Client?  @relation(fields: [clientId], references: [id])
  supplier   Supplier? @relation(fields: [supplierId], references: [id])
  contractor Contractor? @relation(fields: [contractorId], references: [id])
  partner    Partner? @relation(fields: [partnerId], references: [id])
}

model Transfer {
  id             String   @id @default(cuid())
  fromCashboxId  String
  toCashboxId    String
  date           DateTime
  amount         Decimal @db.Decimal(18,2)
  note           String?

  fromCashbox Cashbox @relation("FromCashbox", fields: [fromCashboxId], references: [id])
  toCashbox   Cashbox @relation("ToCashbox", fields: [toCashboxId], references: [id])
}

model BankImport {
  id          String   @id @default(cuid())
  date        DateTime
  amount      Decimal  @db.Decimal(18,2)
  type        String
  reference   String?
  bankName    String?
  description String?
  posted      Boolean  @default(false)

  matchedInstallment Installment? @relation("InstallmentBankImport")

  @@map("bank_imports")
}

// Projects Materials & Phases
model Phase {
  id        String   @id @default(cuid())
  projectId String
  name      String
  startDate DateTime?
  endDate   DateTime?
  progressPct Int?

  project Project @relation(fields: [projectId], references: [id])
  materialMoves MaterialMove[]
  journalLines  JournalLine[]
}

model Material {
  id              String   @id @default(cuid())
  name            String
  unit            String
  defaultUnitCost Decimal? @db.Decimal(18,2)

  moves        MaterialMove[]
  journalLines JournalLine[]
  invoiceLines InvoiceLine[]
}

model MaterialMove {
  id         String           @id @default(cuid())
  projectId  String
  materialId String
  type       MaterialMoveType
  qty        Decimal          @db.Decimal(18,2)
  unitCost   Decimal          @db.Decimal(18,2)
  date       DateTime
  phaseId    String?
  note       String?

  project  Project  @relation(fields: [projectId], references: [id])
  material Material @relation(fields: [materialId], references: [id])
  phase    Phase?   @relation(fields: [phaseId], references: [id])

  @@index([projectId, materialId, date], map: "material_moves_idx")
  @@map("material_moves")
}

// Backups & Logs
model Backup {
  id        String         @id @default(cuid())
  runAt     DateTime
  location  BackupLocation
  pathOrDriveId String
  sizeBytes Int?
  status    BackupStatus
  message   String?
}

model AuditLog {
  id       String   @id @default(cuid())
  actorId  String
  action   String
  entity   String
  entityId String
  meta     Json
  at       DateTime @default(now())

  actor User @relation("UserToAuditLog", fields: [actorId], references: [id])
}
